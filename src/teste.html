<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Contador de Repetições com MediaPipe Pose</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #222;
            height: 100vh;
            margin: 0;
            color: #eee;
            font-family: Arial, sans-serif;
        }

        #videoCanvas {
            max-width: 100vw;
            max-height: 80vh;
            border-radius: 10px;
            box-shadow: 0 0 15px #0f0;
        }

        #info {
            margin-top: 15px;
            font-size: 1.2rem;
            text-align: center;
            background: #333;
            padding: 10px 20px;
            border-radius: 8px;
            width: fit-content;
            min-width: 250px;
        }
    </style>
</head>

<body>

    <canvas id="videoCanvas"></canvas>
    <div id="info">
        <div>Repetições: <span id="counter">0</span></div>
        <div>Estágio: <span id="stage">---</span></div>
        <div>Ângulo: <span id="angle">0.00</span></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script>
        const videoElement = document.createElement('video');
        videoElement.style.display = 'none'; // esconde o vídeo nativo
        document.body.appendChild(videoElement);

        const canvasElement = document.getElementById('videoCanvas');
        const canvasCtx = canvasElement.getContext('2d');

        let counter = 0;
        let stage = '---';
        let lastAngle = 0;

        // Ajustar canvas para o tamanho máximo da câmera disponível
        async function setupCamera() {
            const constraints = {
                audio: false,
                video: {
                    facingMode: 'user',
                    width: { ideal: window.innerWidth },
                    height: { ideal: window.innerHeight }
                }
            };

            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            videoElement.srcObject = stream;

            await videoElement.play();

            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
        }

        function calcularAngulo(a, b, c) {
            const radians = Math.atan2(c[1] - b[1], c[0] - b[0]) - Math.atan2(a[1] - b[1], a[0] - b[0]);
            let angulo = Math.abs(radians * 180.0 / Math.PI);
            if (angulo > 180.0) angulo = 360 - angulo;
            return angulo;
        }

        function valorPoseLandmark(landmarks, index) {
            if (!landmarks || landmarks.length <= index) return [0, 0];
            return [landmarks[index].x, landmarks[index].y];
        }

        function analisarExercicio(landmarks) {
            if (!landmarks) return;

            const LEFT_SHOULDER = 11;
            const LEFT_ELBOW = 13;
            const LEFT_WRIST = 15;

            const leftShoulder = valorPoseLandmark(landmarks, LEFT_SHOULDER);
            const leftElbow = valorPoseLandmark(landmarks, LEFT_ELBOW);
            const leftWrist = valorPoseLandmark(landmarks, LEFT_WRIST);

            const angulo = calcularAngulo(leftShoulder, leftElbow, leftWrist);
            lastAngle = angulo;

            if (angulo > 155) {
                stage = 'baixo';
            }
            if (angulo < 39 && stage === 'baixo') {
                stage = 'cima';
                counter++;
            }
        }


        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.poseLandmarks) {
                drawConnectors(canvasCtx, results.poseLandmarks, window.Pose.POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 4 });
                drawLandmarks(canvasCtx, results.poseLandmarks, { color: '#FF0000', lineWidth: 2 });

                analisarExercicio(results.poseLandmarks);
            }

            canvasCtx.restore();

            document.getElementById('counter').textContent = counter;
            document.getElementById('stage').textContent = stage;
            document.getElementById('angle').textContent = lastAngle.toFixed(2);
        }

        async function main() {
            await setupCamera();

            const pose = new window.Pose({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
            });
            pose.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            pose.onResults(onResults);

            async function detectFrame() {
                await pose.send({ image: videoElement });
                requestAnimationFrame(detectFrame);
            }

            detectFrame();
        }

        main();
    </script>

</body>

</html>